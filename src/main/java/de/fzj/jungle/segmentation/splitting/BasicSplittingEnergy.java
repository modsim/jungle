/**
 * 
 */
package de.fzj.jungle.segmentation.splitting;

import java.awt.Point;
import java.awt.Polygon;
import java.awt.geom.Line2D;
import java.awt.geom.PathIterator;
import java.util.LinkedList;
import java.util.List;

import de.fzj.jungle.segmentation.Orientation;
import de.fzj.jungle.segmentation.RelativePosition;

/**
 * Implements a {@link SplittingEnergy} that takes into account the ratio of the
 * cells that would result from a split. I.e. equal sized results are
 * preferable.
 * 
 * @author Stefan Helfrich
 */
public class BasicSplittingEnergy extends SplittingEnergy
{

	/* Private fields */
	private Polygon contour;

	private Point previousPointA;

	private Point previousPointB;

	/**
	 * Constructs a {@link BasicSplittingEnergy} for a contour (i.e. a
	 * {@link Polygon}).
	 */
	public BasicSplittingEnergy( Polygon contour )
	{
		this.contour = contour;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see de.fzj.helfrich.segmentation.SplittingEnergy#computeEnergy()
	 */
	@Override
	public double computeEnergy( Point A, Point B )
	{
		// 1. Compute distance between two points
		double distance = A.distance( B );

		// 1b. Check if the pixels between A and B are inside of the contour
		Line2D AB = new Line2D.Float( A, B );

		List< Point > pointsAlongLine = getPointsAlongLine( AB );
		if ( !A.equals( B ) )
		{
			pointsAlongLine.remove( 0 );
			pointsAlongLine.remove( pointsAlongLine.size() - 1 );
		}

		for ( Point p : pointsAlongLine )
		{
			if ( !contour.contains( p ) ) { return Double.MAX_VALUE; }
		}
		RelativePosition relativePosition = determineRelativePosition( A, previousPointA, B, previousPointB );

		if ( relativePosition.equals( RelativePosition.OUTSIDE ) ) { return Double.MAX_VALUE; }

		// 2. Compute length of contour-segments generated by splitting at the
		// two points
		// Segment A to B
		Double lengthABSegment = 0.0;
		Double lengthBASegment = 0.0;

		PathIterator iter = this.contour.getPathIterator( null );

		boolean trigger = false;

		Point currentPoint = null;
		Point previousPoint = null;

		Double currentLength = lengthABSegment;

		while ( !iter.isDone() )
		{
			iter.next();

			double[] coords = new double[ 6 ];

			int segmentType = iter.currentSegment( coords );

			double distanceIter = 0.0;

			switch ( segmentType )
			{
			case PathIterator.SEG_MOVETO:
			case PathIterator.SEG_LINETO:
				currentPoint = new Point( ( int ) coords[ 0 ], ( int ) coords[ 1 ] );
				break;
			case PathIterator.SEG_CLOSE:
				break;
			default:
				throw new IllegalArgumentException( "Bad path segment" );
			};

			if ( previousPoint != null )
			{
				distanceIter = currentPoint.distance( previousPoint );
			}

			// currentLength += distanceIter;

			// FIX:BEGIN
			if ( !trigger )
			{
				lengthABSegment += distanceIter;
			}
			else
			{
				lengthBASegment += distanceIter;
			}
			// FIX:END

			previousPoint = currentPoint;

			// Assumption that A is always the first point to occur when
			// iterating
			// FIXME this assumption does not hold!!
			if ( ( A.x == coords[ 0 ] && A.y == coords[ 1 ] ) || ( B.x == coords[ 0 ] && B.y == coords[ 1 ] ) )
			{
				// if (!trigger) {
				// /*
				// * First time
				// */
				//
				// // switch currentLength
				// lengthABSegment += currentLength;
				// currentLength = 0.0;
				//
				// trigger = !trigger;
				// } else {
				// /*
				// * Second time
				// */
				// // switch currentLength
				// lengthBASegment += currentLength;
				// currentLength = 0.0;
				//
				// trigger = !trigger;
				// }
				trigger = !trigger;
			}
		}

		// lengthABSegment += currentLength;

		// 3. Determine minimum of segment-lengths
		double minimum = Math.min( lengthABSegment, lengthBASegment );

		// Store previous points
		previousPointA = A;
		previousPointB = B;

		// 4. Compute energy
		return ( distance / minimum );
	}

	public List< Point > getPointsAlongLine( Line2D line )
	{
		Point p1 = new Point( ( int ) line.getP1().getX(), ( int ) line.getP1().getY() );
		Point p2 = new Point( ( int ) line.getP2().getX(), ( int ) line.getP2().getY() );

		List< Point > points = new LinkedList<>();
		points.add( p1 );

		Point newPoint = new Point( ( int ) ( p1.getX() + ( p2.getX() - p1.getX() ) * 0.5 ), ( int ) ( p1.getY() + ( p2.getY() - p1.getY() ) * 0.25 ) );
		points.add( newPoint );

		points.add( p2 );

		return points;
	}

	public RelativePosition determineRelativePosition( Point A, Point previousPointA, Point B, Point previousPointB )
	{
		// compute outside normal(s) in point A
		double dxA = previousPointA.x - A.x;
		double dyA = previousPointA.y - A.y;

		// determine orientation of contour
		Orientation orientation = BottleneckDetector.computePolygonOrientation( this.contour );

		// There are edge cases where an orientation cannot be determined
		if ( orientation == null ) { return RelativePosition.INDETERMINED; }

		// determine direction such that it is the outside normal
		Point normalA = null;
		switch ( orientation )
		{
		case CLOCKWISE:
			normalA = new Point( ( int ) -dyA, ( int ) dxA );
			break;
		case COUNTERCLOCKWISE:
			normalA = new Point( ( int ) dyA, ( int ) -dxA );
			break;
		default:
			break;
		}

		// compute outside normal in point B
		double dxB = previousPointB.x - B.x;
		double dyB = previousPointB.y - B.y;

		// determine direction such that it is the outside normal
		Point normalB = null;
		switch ( orientation )
		{
		case CLOCKWISE:
			normalB = new Point( ( int ) -dyB, ( int ) dxB );
			break;
		case COUNTERCLOCKWISE:
			normalB = new Point( ( int ) dyB, ( int ) -dxB );
			break;
		default:
			break;
		}

		// compute dot products
		Point AB = new Point( B.x - A.x, B.y - A.y );
		Point BA = new Point( A.x - B.x, A.y - B.y );

		double cos1 = cosineOfAngleBetweenVectors( normalA, AB );
		double cos2 = cosineOfAngleBetweenVectors( normalB, BA );

		// cosine should be less than zero for an inner connection
		if ( cos1 >= 0 && cos2 >= 0 )
		{
			// outside connection
			return RelativePosition.INSIDE;
		}
		else
		{
			// inside connection
			return RelativePosition.OUTSIDE;
		}
	}

	public double dotProduct( Point v1, Point v2 )
	{
		return v1.x * v2.x + v1.y * v2.y;
	}

	public double cosineOfAngleBetweenVectors( Point v1, Point v2 )
	{
		return dotProduct( v1, v2 ) / ( norm( v1 ) * norm( v2 ) );
	}

	public double norm( Point v )
	{
		return Math.sqrt( Math.pow( v.x, 2 ) + Math.pow( v.y, 2 ) );
	}

	@Override
	public double computeEnergy( Point A, Point prevA, Point B, Point prevB )
	{
		// 1. Compute distance between two points
		double distance = A.distance( B );

		if ( distance == 0 ) { return Double.MAX_VALUE - 1; }

		// // 1b. Check if the pixels between A and B are inside of the contour
		// Line2D AB = new Line2D.Float(A, B);
		//
		// List<Point> pointsAlongLine = getPointsAlongLine(AB);
		// if (!A.equals(B)) {
		// pointsAlongLine.remove(0);
		// pointsAlongLine.remove(pointsAlongLine.size()-1);
		// }
		//
		// for (Point p : pointsAlongLine) {
		// if (!contour.contains(p)) {
		// return Double.MAX_VALUE;
		// }
		// }
		// FIXME prevA and prevB should not be null!!! just a workaround
		if ( prevA != null && prevB != null )
		{
			RelativePosition relativePosition = determineRelativePosition( A, prevA, B, prevB );

			if ( relativePosition.equals( RelativePosition.OUTSIDE ) || relativePosition.equals( RelativePosition.INDETERMINED ) ) { return Double.MAX_VALUE; }
		}

		// 2. Compute length of contour-segments generated by splitting at the
		// two points
		// Segment A to B
		Double lengthABSegment = 0.0;
		Double lengthBASegment = 0.0;

		PathIterator iter = this.contour.getPathIterator( null );

		boolean trigger = false;

		Point currentPoint = null;
		Point previousPoint = null;

		boolean visitedA = false;
		boolean visitedB = false;

		while ( !iter.isDone() )
		{
			iter.next();

			double[] coords = new double[ 6 ];

			int segmentType = iter.currentSegment( coords );

			double distanceIter = 0.0;

			switch ( segmentType )
			{
			case PathIterator.SEG_MOVETO:
			case PathIterator.SEG_LINETO:
				currentPoint = new Point( ( int ) coords[ 0 ], ( int ) coords[ 1 ] );
				break;
			case PathIterator.SEG_CLOSE:
				break;
			default:
				throw new IllegalArgumentException( "Bad path segment" );
			};

			if ( previousPoint != null )
			{
				distanceIter = currentPoint.distance( previousPoint );
			}

			// FIX:BEGIN
			if ( !trigger )
			{
				lengthABSegment += distanceIter;
			}
			else
			{
				lengthBASegment += distanceIter;
			}
			// FIX:END

			previousPoint = currentPoint;

			/*
			 * vistedA and visitedB are variables to counter the effect of
			 * overlapping contours. In this scenario either A or B is hit
			 * twice, thus, resulting in a switch. This is not desired
			 * behaviour.
			 */
			if ( ( ( A.x == coords[ 0 ] && A.y == coords[ 1 ] ) && !visitedA ) || ( ( B.x == coords[ 0 ] && B.y == coords[ 1 ] ) && !visitedB ) )
			{
				// switch the trigger
				trigger = !trigger;

				if ( A.x == coords[ 0 ] && A.y == coords[ 1 ] )
				{
					visitedA = true;
				}

				if ( B.x == coords[ 0 ] && B.y == coords[ 1 ] )
				{
					visitedB = true;
				}
			}
		}

		// 3. Determine minimum of segment-lengths
		double minimum = Math.min( lengthABSegment, lengthBASegment );

		// 4. Compute energy
		return ( distance / minimum );
	}

}
